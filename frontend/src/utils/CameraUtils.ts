import * as THREE from "three";
import * as OBC from "@thatopen/components";

/**
 * Utilidades para manejo de c√°mara usando BoundingBoxer
 * Basado en el tutorial oficial: https://docs.thatopen.com/Tutorials/Components/Core/BoundingBoxer
 */

export class CameraUtils {
  private components: OBC.Components;
  private world: any;
  private boxer: OBC.BoundingBoxer;

  constructor(components: OBC.Components, world: any) {
    this.components = components;
    this.world = world;
    this.boxer = components.get(OBC.BoundingBoxer);
  }

  /**
   * Obtiene el bounding box de todos los modelos cargados
   * Implementaci√≥n basada en el tutorial oficial
   */
  private getLoadedModelsBoundings(): THREE.Box3 {
    // Como buena pr√°ctica, limpiar la lista del boxer primero
    // para que no se tengan en cuenta cajas anteriores
    this.boxer.list.clear();

    // A√±adir todos los modelos cargados
    this.boxer.addFromModels();

    // Calcular la caja fusionada de la lista
    const box = this.boxer.get();

    // Como buena pr√°ctica, limpiar la lista despu√©s del c√°lculo
    this.boxer.list.clear();

    // Verificar que el box sea v√°lido
    if (!box || box.isEmpty()) {
      console.warn('‚ö†Ô∏è Bounding box vac√≠o, creando box por defecto');
      // Crear un bounding box por defecto centrado en el origen
      return new THREE.Box3(
        new THREE.Vector3(-35, -35, -35),
        new THREE.Vector3(35, 35, 35)
      );
    }

    console.log('üì¶ Bounding box calculado:', {
      min: box.min,
      max: box.max,
      size: box.getSize(new THREE.Vector3())
    });

    return box;
  }

  /**
   * Obtiene el bounding box de elementos espec√≠ficos usando ModelIdMap
   * @param modelIdMap Mapa de elementos seleccionados por modelo
   */
  private async getBoundingBoxFromModelIdMap(modelIdMap: Record<string, Set<number>>): Promise<THREE.Box3> {
    try {
      this.boxer.list.clear();

      // Agregar elementos al boxer
      await this.boxer.addFromModelIdMap(modelIdMap);

      const box = this.boxer.get();

      // Verificar que el box sea v√°lido
      if (!box || box.isEmpty()) {
        console.warn('‚ö†Ô∏è Bounding box vac√≠o o inv√°lido del boxer, usando m√©todo alternativo');
        return await this.getBoundingBoxFromModelIdMapAlternative(modelIdMap);
      }

      this.boxer.list.clear();
      return box;
    } catch (error) {
      console.warn('‚ö†Ô∏è Error usando boxer, usando m√©todo alternativo:', error);
      return await this.getBoundingBoxFromModelIdMapAlternative(modelIdMap);
    }
  }

  /**
   * M√©todo alternativo para obtener bounding box de elementos espec√≠ficos
   * @param modelIdMap Mapa de elementos seleccionados por modelo
   */
  private async getBoundingBoxFromModelIdMapAlternative(modelIdMap: Record<string, Set<number>>): Promise<THREE.Box3> {
    try {
      const fragments = this.components.get(OBC.FragmentsManager);
      if (!fragments) {
        console.warn('‚ö†Ô∏è Fragments manager no disponible');
        return this.getLoadedModelsBoundings();
      }

      const boundingBox = new THREE.Box3();
      let hasValidBox = false;

      for (const [modelId, localIds] of Object.entries(modelIdMap)) {
        const model = fragments.list.get(modelId);
        if (!model) continue;

        const localIdsArray = Array.from(localIds);
        if (localIdsArray.length === 0) continue;

        try {
          // Obtener las posiciones de los elementos
          const itemsData = await (model as any).getItemsData(localIdsArray, {
            attributesDefault: true
          });

          for (const itemData of itemsData) {
            // Intentar diferentes atributos de posici√≥n
            let position = null;

            if (itemData._position?.value) {
              position = itemData._position.value;
            } else if (itemData.position?.value) {
              position = itemData.position.value;
            } else if (itemData._center?.value) {
              position = itemData._center.value;
            }

            if (position && Array.isArray(position) && position.length >= 3) {
              const point = new THREE.Vector3(position[0], position[1], position[2]);
              boundingBox.expandByPoint(point);
              hasValidBox = true;
            }
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Error obteniendo posiciones de elementos en ${modelId}:`, error);
        }
      }

      if (hasValidBox) {
        console.log('‚úÖ Bounding box calculado usando m√©todo alternativo:', {
          min: boundingBox.min,
          max: boundingBox.max,
          size: boundingBox.getSize(new THREE.Vector3())
        });
        return boundingBox;
      } else {
        console.warn('‚ö†Ô∏è No se pudo calcular bounding box, usando fallback');
        return this.getLoadedModelsBoundings();
      }
    } catch (error) {
      console.error('‚ùå Error en m√©todo alternativo:', error);
      return this.getLoadedModelsBoundings();
    }
  }

  /**
   * Centra la c√°mara en todos los modelos cargados
   */
  async fitToAllModels(): Promise<void> {
    try {
      const box = this.getLoadedModelsBoundings();

      // Verificar que el bounding box sea v√°lido
      if (!box || box.isEmpty()) {
        console.warn('‚ö†Ô∏è Bounding box vac√≠o, intentando centrar con valores por defecto');
        // Posicionar c√°mara en una posici√≥n por defecto m√°s cercana
        const camera = this.world.camera;
        if (camera && camera.controls) {
          await camera.controls.setLookAt(0, 10, 20, 0, 0, 0, true);
        }
        return;
      }

      await this.fitCameraToBox(box);
      console.log('‚úÖ C√°mara centrada en todos los modelos');
    } catch (error) {
      console.error('‚ùå Error al centrar c√°mara en todos los modelos:', error);
    }
  }

  /**
   * Centra la c√°mara en elementos espec√≠ficos
   * @param modelIdMap Mapa de elementos por modelo
   */
  async fitToElements(modelIdMap: Record<string, Set<number>>): Promise<void> {
    try {
      console.log('üéØ Intentando centrar c√°mara en elementos espec√≠ficos:', modelIdMap);

      // Debug: mostrar informaci√≥n detallada del modelIdMap
      for (const [modelId, localIds] of Object.entries(modelIdMap)) {
        console.log(`üìã Modelo ${modelId}: ${localIds.size} elementos`);
      }

      const box = await this.getBoundingBoxFromModelIdMap(modelIdMap);

      if (!box || box.isEmpty()) {
        console.warn('‚ö†Ô∏è Bounding box inv√°lido, usando fitToAllModels como fallback');
        await this.fitToAllModels();
        return;
      }

      console.log('üì¶ Bounding box calculado:', {
        min: box.min,
        max: box.max,
        size: box.getSize(new THREE.Vector3())
      });

      await this.fitCameraToBox(box);
      console.log('‚úÖ C√°mara centrada en elementos seleccionados');
    } catch (error) {
      console.error('‚ùå Error al centrar c√°mara en elementos:', error);
      console.log('üîÑ Usando fitToAllModels como fallback');
      await this.fitToAllModels();
    }
  }

  /**
   * Centra la c√°mara en elementos por GUIDs (√∫til para departamentos)
   * @param guids Array de GUIDs de elementos
   */
  async fitToGuids(guids: string[]): Promise<void> {
    try {
      console.log(`üéØ Intentando centrar en ${guids.length} elementos por GUIDs`);

      // Obtener el fragments manager
      const fragments = this.components.get(OBC.FragmentsManager);
      if (!fragments) {
        console.warn('‚ö†Ô∏è Fragments manager no disponible');
        await this.fitToAllModels();
        return;
      }

      // Buscar elementos por GUIDs en todos los modelos
      const elementsToIsolate: Record<string, Set<number>> = {};

      for (const [modelId, model] of fragments.list) {
        try {
          // Obtener elementos IFCSPACE y IFCDOOR
          let allLocalIds: number[] = [];

          try {
            const spaces = await (model as any).getItemsOfCategories([/IFCSPACE/]);
            if (spaces && typeof spaces === 'object') {
              const spaceIds = Object.values(spaces).flat() as number[];
              allLocalIds = [...allLocalIds, ...spaceIds];
            }

            const doors = await (model as any).getItemsOfCategories([/IFCDOOR/]);
            if (doors && typeof doors === 'object') {
              const doorIds = Object.values(doors).flat() as number[];
              allLocalIds = [...allLocalIds, ...doorIds];
            }
          } catch (categoryError) {
            console.warn(`‚ö†Ô∏è Error obteniendo categor√≠as en ${modelId}:`, categoryError);
            continue;
          }

          if (allLocalIds.length === 0) {
            console.warn(`‚ö†Ô∏è Modelo ${modelId} no tiene elementos IFCSPACE o IFCDOOR`);
            continue;
          }

          // Buscar elementos por GUID
          const modelElements = new Set<number>();

          // Procesar elementos en chunks para evitar sobrecarga
          const CHUNK_SIZE = 50;

          for (let i = 0; i < allLocalIds.length; i += CHUNK_SIZE) {
            const chunk = allLocalIds.slice(i, i + CHUNK_SIZE);

            try {
              const itemsData = await (model as any).getItemsData(chunk, {
                attributesDefault: false,
                attributes: ["_guid"]
              });

              for (let j = 0; j < itemsData.length; j++) {
                const itemData = itemsData[j];
                const localId = chunk[j];

                if (itemData._guid?.value && guids.includes(itemData._guid.value) && typeof localId === 'number') {
                  modelElements.add(localId);
                  console.log(`‚úÖ Coincidencia: GUID ${itemData._guid.value}, localId ${localId} en modelo ${modelId}`);
                }
              }
            } catch (chunkError) {
              console.warn(`‚ö†Ô∏è Error procesando chunk en ${modelId}:`, chunkError);
            }
          }

          if (modelElements.size > 0) {
            elementsToIsolate[modelId] = modelElements;
            console.log(`üì¶ A√±adido modelo ${modelId} con ${modelElements.size} elementos para aislar`);
          }

        } catch (modelError) {
          console.warn(`‚ö†Ô∏è Error procesando modelo ${modelId}:`, modelError);
        }
      }

      // Si encontramos elementos, hacer zoom en ellos
      if (Object.keys(elementsToIsolate).length > 0) {
        console.log(`üéØ Encontrados elementos en ${Object.keys(elementsToIsolate).length} modelos`);
        await this.fitToElements(elementsToIsolate);
        console.log('‚úÖ C√°mara centrada en elementos espec√≠ficos por GUIDs');
      } else {
        console.warn('‚ö†Ô∏è No se encontraron elementos por GUIDs, usando fallback');
        await this.fitToAllModels();
      }

    } catch (error) {
      console.error('‚ùå Error al centrar c√°mara en GUIDs:', error);
      await this.fitToAllModels();
    }
  }

  /**
   * Centra la c√°mara en un elemento espec√≠fico
   * @param modelId ID del modelo
   * @param elementId ID local del elemento
   */
  async fitToElement(modelId: string, elementId: number): Promise<void> {
    const modelIdMap: Record<string, Set<number>> = {
      [modelId]: new Set([elementId])
    };
    await this.fitToElements(modelIdMap);
  }

  /**
   * Hace fit de la c√°mara a un elemento espec√≠fico usando BoundingBoxer
   * Basado en el tutorial oficial: https://docs.thatopen.com/Tutorials/Components/Core/BoundingBoxer
   * @param modelId ID del modelo
   * @param elementId ID del elemento
   */
  async fitToSingleElement(modelId: string, elementId: number): Promise<void> {
    try {
      console.log(`üéØ Haciendo fit al elemento ${elementId} del modelo ${modelId}`);

      // Crear ModelIdMap para el elemento espec√≠fico
      const modelIdMap: Record<string, Set<number>> = {
        [modelId]: new Set([elementId])
      };

      // Obtener bounding box del elemento usando BoundingBoxer
      this.boxer.list.clear();
      await this.boxer.addFromModelIdMap(modelIdMap);
      const box = this.boxer.get();
      this.boxer.list.clear();

      if (!box || box.isEmpty()) {
        console.warn('‚ö†Ô∏è No se pudo obtener bounding box del elemento, usando fallback');
        // Fallback: usar el m√©todo existente
        await this.fitToElement(modelId, elementId);
        return;
      }

      // Crear esfera del bounding box
      const sphere = new THREE.Sphere();
      box.getBoundingSphere(sphere);

      // Ajustar el radio de la esfera para que el elemento se vea m√°s cerca
      sphere.radius *= 0.8; // Reducir el radio para acercar la c√°mara

      console.log('üéØ Ajustando c√°mara a elemento espec√≠fico:', {
        center: sphere.center,
        radius: sphere.radius,
        elementId,
        modelId
      });

      // Hacer fit de la c√°mara a la esfera usando la estructura correcta de ThatOpen
      if (!this.world.camera || !this.world.camera.controls) {
        console.warn('‚ö†Ô∏è Controles de c√°mara no disponibles');
        // Fallback: usar el m√©todo existente
        await this.fitToElement(modelId, elementId);
        return;
      }

      try {
        // Usar fitToSphere para centrar la c√°mara en el elemento
        await this.world.camera.controls.fitToSphere(sphere, true);
        console.log('‚úÖ Fit completado usando BoundingBoxer para elemento espec√≠fico');
      } catch (error) {
        console.error('‚ùå Error ajustando c√°mara al elemento:', error);
        // Fallback al m√©todo existente
        await this.fitToElement(modelId, elementId);
      }

    } catch (error) {
      console.warn('‚ö†Ô∏è Error haciendo fit con BoundingBoxer:', error);
      // Fallback al m√©todo existente
      await this.fitToElement(modelId, elementId);
    }
  }

  /**
   * Ajusta la c√°mara a un bounding box espec√≠fico
   * @param box Bounding box de THREE.js
   */
  private async fitCameraToBox(box: THREE.Box3): Promise<void> {
    if (!this.world.camera || !this.world.camera.controls) {
      console.warn('Controles de c√°mara no disponibles');
      return;
    }

    // Verificar que el box sea v√°lido
    if (!box || box.isEmpty()) {
      console.warn('‚ö†Ô∏è Bounding box inv√°lido en fitCameraToBox');
      return;
    }

    // Calcular esfera envolvente del bounding box
    const sphere = new THREE.Sphere();
    box.getBoundingSphere(sphere);

    // Verificar que la esfera sea v√°lida
    if (sphere.radius <= 0) {
      console.warn('‚ö†Ô∏è Radio de esfera inv√°lido:', sphere.radius);
      return;
    }

    // Ajustar el radio de la esfera para que el modelo se vea m√°s cerca
    sphere.radius *= 0.8; // Reducir el radio para acercar la c√°mara

    console.log('üéØ Ajustando c√°mara a esfera:', {
      center: sphere.center,
      radius: sphere.radius,
      boxSize: box.getSize(new THREE.Vector3())
    });

    try {
      // Usar fitToSphere para centrar la c√°mara
      await this.world.camera.controls.fitToSphere(sphere, true);
      console.log('‚úÖ C√°mara ajustada exitosamente');
    } catch (error) {
      console.error('‚ùå Error ajustando c√°mara:', error);
    }
  }

  /**
   * Obtiene informaci√≥n de c√°mara para una orientaci√≥n espec√≠fica
   * @param orientation Orientaci√≥n deseada
   */
  async getCameraOrientation(
    orientation: "front" | "back" | "left" | "right" | "top" | "bottom"
  ): Promise<{ position: THREE.Vector3; target: THREE.Vector3 }> {
    // Asegurar que el boxer tenga los modelos cargados
    this.getLoadedModelsBoundings();

    // Usar el m√©todo oficial del boxer para obtener la orientaci√≥n
    return await this.boxer.getCameraOrientation(orientation);
  }

  /**
   * Establece la vista desde una orientaci√≥n espec√≠fica
   * @param orientation Orientaci√≥n deseada
   */
  async viewFromOrientation(
    orientation: "front" | "back" | "left" | "right" | "top" | "bottom"
  ): Promise<void> {
    const camera = this.world.camera;
    if (!camera.hasCameraControls()) {
      console.warn('Controles de c√°mara no disponibles');
      return;
    }

    try {
      const { position, target } = await this.getCameraOrientation(orientation);

      await camera.controls.setLookAt(
        position.x, position.y, position.z,
        target.x, target.y, target.z,
        true // animaci√≥n
      );

      console.log(`‚úÖ Vista establecida desde orientaci√≥n: ${orientation}`);
    } catch (error) {
      console.error(`‚ùå Error al establecer vista ${orientation}:`, error);
    }
  }

  /**
   * Establece vista 2D cenital con rotaci√≥n personalizada para el norte del proyecto
   * @param northRotationDegrees √Ångulo de rotaci√≥n del norte en grados (por defecto 99.01)
   */
  async viewFrom2DTop(northRotationDegrees: number = 99.01): Promise<void> {
    const camera = this.world.camera;
    if (!camera.hasCameraControls()) {
      console.warn('Controles de c√°mara no disponibles');
      return;
    }

    try {
      // Obtener el bounding box de todos los modelos
      const box = this.getLoadedModelsBoundings();

      if (box) {
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // Posicionar c√°mara desde arriba
        const height = Math.max(size.x, size.z) * 1.5; // Altura basada en el tama√±o del modelo

        // Rotaci√≥n para alinear con el norte del proyecto
        // Convertir grados a radianes
        const northRotationRadians = (northRotationDegrees * Math.PI) / 180;

        // Calcular posici√≥n de c√°mara con rotaci√≥n m√°s efectiva
        const radius = height * 0.8; // Radio para la posici√≥n de la c√°mara
        const offsetX = Math.sin(northRotationRadians) * radius * 0.01;
        const offsetZ = Math.cos(northRotationRadians) * radius * 0.01;

        const cameraPosition = new THREE.Vector3(
          center.x + offsetX,
          center.y + height,
          center.z + offsetZ
        );
        const target = new THREE.Vector3(center.x, center.y, center.z);

        console.log('üéØ Configurando vista 2D con rotaci√≥n:', {
          northRotationDegrees,
          northRotationRadians,
          cameraPosition,
          target,
          center,
          size
        });

        // Usar setLookAt para posicionar la c√°mara
        await camera.controls.setLookAt(
          cameraPosition.x, cameraPosition.y, cameraPosition.z,
          target.x, target.y, target.z,
          true // animate
        );

        // Para vista 2D cenital, mantener el vector up est√°ndar (0,1,0)
        // Esto asegura que la c√°mara est√© completamente paralela al suelo
        if (camera.three && camera.controls) {
          // Vector up est√°ndar para vista cenital perfecta
          camera.three.up.set(0, 1, 0);
          camera.three.updateProjectionMatrix();
          // Forzar actualizaci√≥n de los controles con delta time
          if (typeof camera.controls.update === 'function') {
            try {
              camera.controls.update(0.016); // ~60fps delta time
            } catch (e) {
              console.warn('No se pudo actualizar los controles:', e);
            }
          }
        }

        console.log('‚úÖ Vista 2D cenital establecida con rotaci√≥n personalizada:', northRotationDegrees, 'grados');
        console.log('C√°mara posicionada en:', cameraPosition, 'mirando a:', target);
      } else {
        console.warn('No se pudo obtener el bounding box del modelo');
      }
    } catch (error) {
      console.error('‚ùå Error al establecer vista 2D cenital:', error);
    }
  }

  /**
   * Obtiene el bounding box de elementos de una categor√≠a espec√≠fica
   * @param category Categor√≠a IFC (ej: "IFCWALL", "IFCDOOR")
   * @param modelId ID del modelo (opcional, si no se especifica busca en todos)
   */
  async getBoundingBoxByCategory(category: string, modelId?: string): Promise<THREE.Box3 | null> {
    try {
      const fragments = this.components.get(OBC.FragmentsManager);

      // Si se especifica un modelo, usar solo ese
      let targetModelId = modelId;
      if (!targetModelId) {
        // Buscar el primer modelo disponible
        const modelIds = Array.from(fragments.list.keys());
        if (modelIds.length === 0) {
          console.warn('No hay modelos cargados');
          return null;
        }
        targetModelId = modelIds[0];
      }

      const model = fragments.list.get(targetModelId);
      if (!model) {
        console.warn(`Modelo ${targetModelId} no encontrado`);
        return null;
      }

      // Obtener elementos de la categor√≠a
      const items = await model.getItemsOfCategories([new RegExp(`^${category}$`)]);
      const localIds = Object.values(items).flat();

      if (localIds.length === 0) {
        console.warn(`No se encontraron elementos de categor√≠a ${category}`);
        return null;
      }

      // Crear ModelIdMap para los elementos encontrados
      const modelIdMap: Record<string, Set<number>> = {
        [targetModelId]: new Set(localIds)
      };

      return await this.getBoundingBoxFromModelIdMap(modelIdMap);
    } catch (error) {
      console.error(`Error al obtener bounding box de categor√≠a ${category}:`, error);
      return null;
    }
  }

  /**
   * Centra la c√°mara en elementos de una categor√≠a espec√≠fica
   * @param category Categor√≠a IFC
   * @param modelId ID del modelo (opcional)
   */
  async fitToCategory(category: string, modelId?: string): Promise<void> {
    const box = await this.getBoundingBoxByCategory(category, modelId);
    if (box) {
      await this.fitCameraToBox(box);
      console.log(`‚úÖ C√°mara centrada en categor√≠a: ${category}`);
    }
  }

  /**
   * Crea un helper visual para mostrar el bounding box
   * @param box Bounding box a visualizar
   * @param color Color del helper (opcional)
   */
  createBoxHelper(box: THREE.Box3, color: number = 0xff0000): THREE.Box3Helper {
    const helper = new THREE.Box3Helper(box, new THREE.Color(color));
    this.world.scene.three.add(helper);
    return helper;
  }

  /**
   * Elimina un helper del bounding box
   * @param helper Helper a eliminar
   */
  disposeBoxHelper(helper: THREE.Box3Helper): void {
    const disposer = this.components.get(OBC.Disposer);
    disposer.destroy(helper);
  }

  /**
   * Configura la velocidad del zoom con rueda del mouse
   * @param speed Velocidad del zoom (por defecto 1.0, valores m√°s altos = zoom m√°s r√°pido)
   */
  setZoomSpeed(speed: number): void {
    const camera = this.world.camera;
    if (camera.hasCameraControls()) {
      camera.controls.dollySpeed = speed;
      console.log(`‚öôÔ∏è Velocidad de zoom actualizada: ${speed}`);
    } else {
      console.warn('‚ö†Ô∏è No se pueden configurar los controles de c√°mara - controles no disponibles');
    }
  }

  /**
   * Configura la velocidad del zoom por defecto (m√°s sensible)
   */
  setDefaultZoomSpeed(): void {
    this.setZoomSpeed(8.0); // Zoom m√°s sensible por defecto
  }

  /**
   * Obtiene la velocidad actual del zoom
   * @returns Velocidad actual del zoom o null si no est√° disponible
   */
  getZoomSpeed(): number | null {
    const camera = this.world.camera;
    if (camera.hasCameraControls()) {
      return camera.controls.dollySpeed;
    }
    return null;
  }
}

/**
 * Funci√≥n de conveniencia para crear una instancia de CameraUtils
 * @param components Instancia de componentes
 * @param world Instancia del mundo
 */
export function createCameraUtils(components: OBC.Components, world: any): CameraUtils {
  return new CameraUtils(components, world);
}

/**
 * Funci√≥n global para centrar el modelo en el visor despu√©s de b√∫squedas
 * Esta funci√≥n se puede llamar desde cualquier parte de la aplicaci√≥n
 */
export function centerModelInViewer() {
  try {
    // Obtener la instancia global de CameraUtils si existe
    const globalCameraUtils = (window as any).cameraUtils;
    if (globalCameraUtils && typeof globalCameraUtils.fitToAllModels === 'function') {
      globalCameraUtils.fitToAllModels();
      console.log('‚úÖ Modelo centrado usando CameraUtils global');
      return true;
    } else {
      console.warn('‚ö†Ô∏è CameraUtils global no disponible');
      return false;
    }
  } catch (error) {
    console.error('‚ùå Error al centrar modelo:', error);
    return false;
  }
} 